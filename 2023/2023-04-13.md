# Algorithm
list의 pop 메서드와 전역 변수를 조심하다.

리스트 _li를 함수 dfs의 인자로 전달하면, 실제로는 _li가 참조(reference)로 전달된다. 즉, _li와 전달된 리스트는 동일한 메모리 공간을 참조하게 된다. 따라서, _li의 값을 변경하면 전달된 리스트 역시 변경된다.

그러나, _li.pop()은 리스트의 마지막 요소를 삭제하면서 리스트 자체를 변경하는 연산이다. 따라서, _li 리스트가 원래의 상태로 되돌아가게 된다. 반면에, _li[-1]은 리스트의 마지막 요소를 반환하여 이를 사용하는 방식으로 리스트를 수정하는 것이다. 따라서, _li[-1]을 사용하면 리스트가 원래의 상태가 아닌, 값이 추가된 상태로 유지된다.

따라서, _li.pop() 대신 _li[-1]을 사용하여 리스트의 마지막 요소를 삭제하도록 수정하면 값이 제대로 추가되고 삭제된다.

# Java의 컴파일 과정
## 어플리케이션이 실행되면 JVM이 OS로부터 메모리를 할당 받는다.
> JVM은 할당 받은 메모리를 용도에 따라 영역을 분리하여 관리한다.

## 자바 컴파일러가(javac.exe)가 자바 소스코드(.java)를 읽어 바이트 코드(.class)로 변환한다.


## 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올립니다.
로드, 검증, 준비, 분석, 초기화의 과정이 진행된다.

## 로딩된 바이트 코드는 Execution Engine을 통해 해석된다.

### Execution Engine의 구성

#### 인터프리터
- 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
- 하나하나의 실행은 빠르나, 같은 메서드라도 여러번 호출되어 새로 수행하는 단점

#### JIT 컴파일러(Just-In-Time Compiler)
- 인터프리터의 단점을 보완
- 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경
- 반복되는 코드를 발견하여 전체 바이트 코드로 컴파일하고 Native Code로 변경하여 사용한

> Native: 자바에서 부모가 되는 C언어나 C++, 어셈블리어를 의미

#### Garbage Collector
- 더 이상 참조되지 않는 메모리 객체를 모아 제거하는 역할을 수행

## JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다.
