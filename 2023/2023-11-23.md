# Implicit Threading
개발자에서 컴파일러 및 런타임 라이브러리로 스레드 생성 및 관리를 맡기는 것을 의미한다.

## Thread Pools
제한되지 않은 스레드는 CPU 시간 또는 메모리와 같은 시스템 리소스를 소진할 수 있다.

Thread Pools은 시작할 때 미리 여러 개의 스레드를 생성하여 작업을 기다리는 풀에 배치한다.

### 장점
1. 기존 스레드를 사용하여 요청을 처리하는 것이 스레드 생성을 기다리는 것보다 빠르다.
2. 스레드 풀은 한 지점에 존재하는 스레드의 수를 제한한다. 이는 특히 많은 수의 동시 스레드를 지원할 수 없는 시스템에서 중요하다.
3. 수행할 작업과 작업 생성 메커니즘을 분리하면 작업을 실행하는 데 다른 전략을 사용할 수 있다. 

### 단점
1. 자원 소비: 스레드 풀에 너무 많은 양의 스레드를 만들어둔다면 메모리 낭비가 심해질 수 있다는 점이다.

## Java Executor 인터페이스
Executor 인터페이스는 Java에서 스레드 생성 및 관리를 추상화하기 위한 인터페이스이다. 주로 스레드 풀을 관리하고 작업을 비동기적으로 실행하는데 사용된다.

```java
public static void main(String[] args){
    Executor executor = Executors.newFixedThreadPool(3);

    Runnable runnable = () -> {
        System.out.println("Hello from Runnable");
    };

    executor.execute(runnable);
}
```

### newSingleThreadExecutor()
- 특징: 크기가 1인 스레드 풀을 생성한다.
- 용도: 작업을 순차적으로 실행하거나, 한 번에 하나의 작업만을 처리해야 할 때 유용하다.
- 장점: 작업 큐에 들어온 순서대로 실행되며, 순차적으로 처리되기 때문에 예측 가능한 동작을 보장한다.
- 단점: 단일 스레드이기 때문에 병렬성을 활용할 수 없다. 작업을 처리하는 속도에 따라 큐에 쌓일 수 있으므로, 작업이 길게 걸리는 경우 효율성이 떨어질 수 있다.

### newFixedThreadPool(nThread) 
- 특징: 크기가 고정된 스레드 풀을 생성한다. 풀에는 지정된 개수(nThread)의 스레드가 유지된다.
- 용도: 동시에 여러 작업을 병렬로 처리해야 할 때 사용한다.
- 장점: 풀에 유지되는 스레드의 개수가 고정되어 있어서, 너무 많은 스레드가 생성되어 시스템 부하를 일으키는 것을 방지한다.
- 단점: 스레드 개수가 고정되어 있기 때문에 작업 부하가 증가하면 성능에 영향을 미칠 수 있다.

### newCachedThreadPool()
- 특징: 필요에 따라 스레드를 동적으로 생성하고, 불필요한 스레드를 제거하여 크기가 자동으로 조절되는 스레드 풀을 생성한다.
- 용도: 각 작업이 짧은 시간 동안 수행되는 경우나, 작업 부하가 변동적인 경우에 유용하다.
- 장점: 풀에는 필요한 만큼의 스레드가 생성되기 때문에 자원의 효율성을 높일 수 있습니다.
- 단점: 스레드의 동적 생성 및 해제로 인해 오버헤드가 발생할 수 있다. 스레드 개수를 제한하지 않기 때문에 너무 많은 스레드가 생성되어 시스템에 부하를 줄 수 있다.

### newWorkStealingPool()
- 특징: Java 8에서 도입된 ForkJoinPool을 사용하여 작업을 분할하고 여러 프로세서에서 병렬로 실행할 수 있는 스레드 풀을 생성한다.
- 용도: 작업을 작은 단위로 분할하고, 여러 코어에서 효율적으로 실행할 때 사용한다. 병렬성이 높은 작업을 작은 단위로 분할하고 병렬로 실행하는데 적합하다. 특히 각 작업이 서로 독립적이고, 작은 단위로 쪼개어 병렬로 실행될 수 있는 경우에 유리하다. newWorkStealingPool()은 다중 코어 또는 프로세서 시스템에서 효과적으로 작동한다. 각각의 프로세서가 자신의 큐에서 작업을 처리하면서 효율적으로 병렬성을 높일 수 있다. 대용량의 작업을 작은 단위로 나누어 각각을 병렬로 처리하고자 할 때 적합하다. 예를 들어, 대규모 데이터 처리 또는 재귀적인 작업 등이 이에 해당할 수 있다.
- 장점: ForkJoinPool은 워크 스틸링(work-stealing) 알고리즘을 사용하여 각 프로세서가 할당된 큐에서 작업을 훔치는 방식으로 병렬 처리를 수행한다.
- 단점: 일부 특수한 경우에는 다른 스레드 풀보다 높은 오버헤드가 발생할 수 있다. 특별한 작업 유형에 대한 최적화가 아닌 경우에는 다른 풀보다 복잡할 수 있다.

> ForkJoinPool은 워크 스틸링(Work-Stealing) 알고리즘을 기반으로 동작다. 각 워커 스레드는 자신의 작업이 끝날 때 다른 워커 스레드의 큐에서 작업을 훔쳐올 수 있다. 이를 통해 작업이 균형 있게 분배되고, 부하가 고르게 분산된다. ForkJoinPool은 작업을 작은 단위로 분할하고, 분할된 작업을 병렬로 실행하여 다중 코어를 활용한다. 큰 작업을 여러 작은 작업으로 나누어 각각을 병렬로 실행함으로써 성능을 향상시킬 수 있다.