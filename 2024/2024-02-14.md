## 언두 로그
InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이렇게 **백업된 데이터를 언두 로그(Undo Log)**라고 한다. 언두 로그가 어떻게 사용되는지 간단히 한번 살펴보자. 

- 트랜잭션 보장: 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구한다. 
- 격리 수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다. 

언두 로그는 InnoDB 스토리지 엔진에서 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요하다. 여기서는 언두 로그가 어떤 문제점을 가지고 있고, 이를 위해 InnoDB 스토리지 엔진이 어떤 기능을 제공하는지 살펴보자. 


### 언두 로그 레코드 모니터링
언두 로그의 데이터가 어떻게 저장되고 어떤 목적으로 사용되는지 살펴보자. 언두 영역은 INSERT, UPDATE, DELETE 같은 문장으로 데이터를 변경했을 때 **변경되기 전의 데이터(이전 데이터)를 보관하는 곳**이다. 예를 들어, 다음과 같은 업데이트 문장을 실행했다고 해보자.
```sql
UPDATE nember SET name='홍길동' WHERE member_id=1;
```
위 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 '홍길동'으로 변경된다. 그리고 변경되기 전의 값이 '벽계수'였다면, 언두 영역에는 '벽계수'라는 값이 백업되는 것이다. 이 상태에서 사용자가 커밋하면 현재 상태가 그대로 유지되고, 롤백하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다. 

#### 언두 로그 데이터 영역 용도
언두 로그의 데이터는 크게 두 가지 용도로 사용되는데, 첫 번째 용도가 바로 위에서 언급한 **트랜잭션의 롤백 대비용**이다. 두 번째 용도는 **트랜잭션의 격리 수준을 유지**하면서 높은 동시성을 제공하는 데 있다. 트랜잭션의 격리 수준이라는 개념이 있는데, 이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준이다.


#### 대용량 처리에서 언두 로그 문제점
MySQL 5.5 이전 버전의 MySQL 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다. 예를 들어, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 DELETE로 삭제한다고 가정해보자. 그러면 MySQL 서버는 이 테이블에서 레코드를 한 건 삭제하고 언두 로그에 삭제되기 전 값을 저장한다. 이렇게 1억 건의 레코드가 테이블에서는 삭제되지만 언두 로그로 복사돼야 한다. 즉, 테이블의 크기만큼 언두 로그의 공간 사용량이 늘어나 결국 언두 로그 공간이 100GB가 되는 것이다. 

대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때도 언두 로그의 양은 급격히 증가할 수 있다. 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다. 아래 그림은 3개의 트랜잭션이 서로 시작과 종료 시점이 다르게 실행되는 것을 보여준다. 그림에서 B 트랜잭션과 C 트랜잭션은 완료됐지만 가장 먼저 시작된 트랜잭션 A는 아직 완료되지 않은 상태다. 이때 트랜잭션 B와 C는 각각 UPDATE와 DELETE를 실행했으므로 변 경 이전의 데이터를 언두 로그에 백업했을 것이다. 하지만 먼저 시작된 A 트랜잭션이 아직 활성 상태이 기 때문에 B와 C 트랜잭션의 완료 여부와 관계없이 B와 C 트랜잭션이 만들어낸 언두 로그는 삭제되지 않는다.

![](https://velog.velcdn.com/images/chocochip/post/a1fc6b5d-9885-4d58-9c93-c1ff880dcc13/image.jpeg)

**일반적으로 응용 프로그램에서 트랜잭션 관리가 잘못된 경우 이런 현상이 발생할 수 있지만 사용자의 실수로 인해 더 자주 문제가 되곤 한다.** 서비스용으로 사용되는 MySQL 서버에서 사용자가 트랜잭션을 시작한 상태에서 완료하지 않고 하루 정도 방치했다고 가정해보자. 그러면 InnoDB 스토리지 엔진은 이 트랜잭션이 시작된 시점부터 생성된 언두 로그를 계속 보존할 것이다. 결국 InnoDB 스토리지 엔진의 언두 로그는 하루치 데이터 변경을 모두 저장하고, 디스크의 언두 로그 저장 공간은 계속 증가한다. 이렇게 누적된 언두 로그로 인해 디스크의 사용량이 증가하는 것은 그다지 큰 문제가 아닐 수도 있다. 하지만 그동안 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 InnoDB 스토리지 엔진은 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어지게 된다. 


#### 언두 로그 자동 해제
MySQL 5.5 버전까지는 이렇게 언두 로그의 사용 공간이 한 번 늘어나면 MySQL 서버를 새로 구축하지 않는 한 줄일 수가 없었다. 언두 로그가 늘어나면 디스크 사용량뿐만 아니라 매번 백업할 때도 그만큼 더 복사를 해야 하는 문제점이 발생한다. 다행스럽게도 MySQL 5.7과 MySQL 8.0으로 업그레이드 되면서 언두 로그 공간의 문제점은 완전히 해결됐다. MySQL 8.0에서는 **언두 로그를 돌아가면서 순차 적으로 사용해 디스크 공간을 줄이는 것도 가능하며, 때로는 MySQL 서버가 필요한 시점에 사용 공간 을 자동으로 줄여 주기도 한다.**

하지만 여전히 서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다. 그래서 MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링하는 것이 좋은 데, 다음과 같이 MySQL 서버의 언두 로그 레코드 건수를 확인할 수 있다.

```sql
// MySQL 8.0 버전에서 사용 가능한 명령어
SELECT count
	FROM information_schema.innodb_metrics
    WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

MySQL 서버에서 실행되는 INSERT, UPDATE, DELETE 문장이 얼마나 많은 데이터를 변경하느냐에 따라 평상시 언두 로그에 존재하는 레코드 건수는 상이할 수 있다. 그래서 MySQL 서버별로 이 값은 차이를 보이는데, 서버별로 안정적인 시점의 언두 로그 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증 여부를 모니터링하는 것이 좋다. 

### 언두 테이블스페이스 관리
**언두 로그가 저장되는 공간을 언두 테이블스페이스(Undo Tablespace)**라고 한다. 언두 테이블스페이스는 MySQL 서버의 버전별로 많은 변화가 있었다. MySQL 5.6 이전 버전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata, ibd) 에 저장됐다. 하지만 시스템 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다. 그래서 MySQL 5.6 버전에서는 `innodb_ undo_tablespaces` 시스템 변수가 도입됐고, `innodb_undo_tablespaces` 시스템 변수를 2보다 큰 값을 설정하면 InnoDB 스토리지 엔진은 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고 별도의 언두 로그 파일을 사용한다. 하지만 MySQL 5.6 이후 버전에서도 `innodb_ undo_tablespaces`를 0으로 설 정하면 여전히 MySQL 5.6 이전의 버전과 동일하게 언두 로그가 시스템 테이블스페이스에 저장됐다. MySQL 8.0으로 업그레이드되면서(MySQL 8.0.14 버전부터) `innodb_undo_tablespaces` 시스템 변수는 효력이 없어졌으며(Deprecated) 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됐다.

#### 언두 테이블스페이스 구조
아래 그림은 언두 테이블스페이스가 어떤 형태로 구성되는지를 보여준다. 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가진다. 

![](https://velog.velcdn.com/images/chocochip/post/ea34b4e1-9a4a-464a-a6e2-a401082676c2/image.jpeg)

하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼의 언두 슬롯을 가진다. 예를 들어, InnoDB의 페이지 크기가 16KB라면 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖게 된다. **하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 INSERT, UPDATE, DELETE 문장의 특성에 따라 최대 4개까지 언두 슬롯을 사용하게 된다.** 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다. 그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음 수식으로 예측해볼 수 있다. 

```
최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이 스 개수) 
```
가장 일반적인 설정인 16KB InnoDB에서 기본 설정(`innodb_undo_tablespaces`=2, `innodb_rollback_segments`=128)을 사용한다고 가정하면 대략 2097152(=16 \* 1024 \* 128 \* 2 / 2)개 정도의 트랜잭션이 동시에 처리 가능해진다. 물론 일반적인 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 **기본값으로 해서 크게 문제될 건 없으므로 가능하면 기본값을 유지하자**. **언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.** 언두 로그 관련 시스템 변수를 변경해야 한다면 적절히 필요한 동시 트랜잭선 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다. 


#### 언두 로그 변경
MySQL 8.0 이전까지는 한 번 생성된 언두 로그는 변경이 허용되지 않고 정적으로 사용됐지만 MySQL 8.0 버전부터는 CREATE UNDO TABLESPACE나 DROP TABLESPACE 같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선됐다.

> MySQL 5.6 이전 버전 에서는 언두 로그는 모두 시스템 테이블스페이스(ibdata.ibd)에 저장됐다. 하지만 시스템 테이블스페이스의 언두 로 그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다. 그래서 MySQL 5.6 버전에서는 `innodb_undo_tablespaces` 시스템 변수가 도입됐고, `innodb_undo_tablespaces` 시스템 변수에 2보다 큰 값을 설정하면 InnoDB 스토리지 엔진은 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고 별도의 언두 로그 파일을 사용한다. 하지만 MySQL 5.6 이후 버전에서도 `innodb_undo_tablespaces`를 0으로 설정하면 여전히 MySQL 5.6 이전의 버전과 동일하게 언두 로그가 시스템 테이블스페이스에 저장됐다. MySQL 8.0으로 업그레이드되면서(MySQL 8.0.14 버전부터) `innodb_undo_tablespaces` 시스템 변수는 효력이 없어졌으며(Deprecated), 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됐다. 


#### 언두 테이블스페이스 공간 반납
언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것을 Undo tablespace truncate라고 한다. 언두 테이블스페이스의 불필요한 공간을 잘라내는(Truncate) 방법은 자동과 수동으로 두 가지 방법이 있는데, 두 가지 방법 모두 MySQL 8.0부터 지원된다. 

- 자동 모드: 트랜잭션이 데이터를 변경하면 이전 버전의 데이터를 언두 로그로 기록하는데, 트랜잭션이 커밋되면 더 이상 언두 로그에 복사된 이전 값은 불필요해진다. InnoDB 스토리지 엔진의 퍼지 스레드(Purge Thread)는 주기적으로 깨어나서 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업을 실행하는데, 이 작업을 언두 퍼지 (Undo Purge)라고 한다. MySQL 서버의 `innodb_undo_log_truncate` 시스템 변수가 ON으로 설정되면, **퍼지 스레드는 주기적으로 언두 로그 파일에서 사용되지 않는 공간을 잘라내고 운영체제로 반납하게 된다.** 언두 로그 파일을 잘라내는 작업을 더 빈번하게 또는 덜 빈번하게 실행되게 하려면 `innodb_purge_rseg_truncate_frequency` 시스템 변수의 값을 조정하면 된다. 
- 수동 모드: `innodb_undo_log_truncate` 시스템 변수가 OFF로 설정되어 언두 로그 파일의 잘라내기가 자동으로 실행되지 않거나 예상보다 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우에는 **언두 테이블스페이스를 비활성화해서 언두 테이블스페이스가 더이상 사용되지 않도록 설정하면 퍼지 스레드는 비활성 상태의 언두 테이블 스페이스를 찾아서 불필요한 공간을 잘라내고 운영체제로 해당 공간을 반납하게 된다.** 반납이 완료되면 언두 테이 블스페이스를 다시 활성화한다. **그리고 수동 모드는 언두 테이블스페이스가 최소 3개 이상은 돼야 작동한다는 것도 기억해 두자. **


```sql
-- // 언두 테이블스페이스 비활성화 
mysql> ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;

-- / / 퍼지 스레드에 의해 언두 테이블스페이스 공간이 반납되면 다시 활성화 
mysql> ALTER UNDO TABLESPACE tablespace_name SET ACTIVE; 
```

