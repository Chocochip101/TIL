### 버퍼 풀과 리두 로그
**리두 로그란 MySQL 장애 시 Buffer pool에 저장되어 있던 데이터의 유실을 방지(데이터 복구)하기 위해 사용된다.** InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다. 물론 **이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이라면 더는 버퍼 풀 크기를 늘려도 성능에 도움이 되지 않겠지만, 그렇지 않다면 디스크의 데이터가 버퍼 풀 메모리로 적재되면 성능이 좋아질 것이다.** 하지만 InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데, 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키는 것이다. InnoDB 버퍼 풀의 쓰기 버퍼링 기능까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 이해해야 한다.

![](https://velog.velcdn.com/images/chocochip/post/0383c47d-342c-4e3a-b895-70ad9c24c6f2/image.jpg)

InnoDB의 버퍼 풀은 **디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)**와 함께 **INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더터 페이지(Dirty Page)**를 함께 가지고 있다. 더티 페이지는 디스크와 메모리(버퍼 풀)의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록돼야 한 다. 하지만 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것은 아니다. **InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용**한다. 즉, 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다. 그래서 InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 하는데, **재사용 불가능한 공간을 활성 리두 로그(Active Redo Log) 라고 한다.** 위 그림에서 화살표를 가진 엔트리들이 활성 리두 로그 공간인 것이다. 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖게 되는데, 이를 LSN(Log Sequence Number)이라고 한다. InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하는데, 이렇게 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다. 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기 때문에 체크포인트와 무관하다. 그리고 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지 (Checkpoint Age)라고 한다. 즉 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다. InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체 크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다. 물론 당연히 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야 한다. 

#### 예제
이제 버퍼 풀의 더티 페이지 비율과 리두 로그 파일의 전체 크기가 어떤 관계인지 이해했으니 실제 간단한 예제를 한번 생각해보자.

1. InnoDB 버퍼 풀은 100GB이며 리두 로그 파일의 전체 크기는 100MB인 경우 
2. InnoDB 버퍼 풀은 100MB이며 리두 로그 파일의 전체 크기는 100GB인 경우 

1번의 경우 리두 로그 파일의 크기가 100MB밖에 안되기 때문에 체크포인트 에이지(Checkpoint Age)도 최대 100MB만 허용된다. 예를 들어, 평균 리두 로그 엔트리가 4KB였다면 25600개 (100MB/4KB) 정도의 더티 페이지만 버퍼 풀에 보관할 수 있게 된다. 데이터 페이지가 16KB라고 가 정한다면 허용 가능한 전체 더티 페이지의 크기는 400MB 수준밖에 안 되는 것이다. 결국 이 경우는 버퍼 풀의 크기는 매우 크지만 실제 쓰기 버퍼링을 위한 효과는 거의 못 보는 상황인 것이다. 2번의 경우 도 1번과 동일한 방식으로 계산해볼 수 있는데, 대략 400GB 정도의 더티 페이지를 가질 수 있다. 하 지만 버퍼 풀의 크기가 100MB이기 때문에 최대 허용 가능한 더티 페이지는 100MB 크기가 된다(물론 InnoDB 버퍼 풀의 여러 가지 설정으로 인해 100MB까지는 아니지만 여기서는 설명의 편의를 위해서다). 

그렇다면 1번과 2번 중 어떤 경우가 좋은 것일까? 사실 둘 다 좋은 설정은 아니라고 할 수 있다. 1번 의 경우는 잘못된 설정이라는 것을 쉽게 알 수 있다. 그리고 2번의 경우는 이론적으로는 아무 문제가 없어 보여도 실제 이 상태로 서비스를 운영하다 보면 **급작스러운 디스크 쓰기가 발생할 가능성이 높다**. 버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB 스토리지 엔진은 매우 많은 더티 페이지를 한 번에 기록해야 하는 상황이 온다. 처음부터 리두 로그 파일의 크기를 적절히 선택하기 어렵다면 버퍼 풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가면서 최적값을 선택하는 것이 좋다.

> 당연한 이야기지만 버퍼 풀의 크기가 100GB라고 해서 리두 로그의 공간이 100GB가 돼야 한다는 것은 아니다. 일반적으로 리두 로그는 변경분만 가지고 버퍼 풀은 데이터 페이지를 통째로 가지기 때문에 데이터 변경이 발생해도 리두 로그는 훨씬 작은 공간만 있으면 된다.

### 버퍼 풀 플러시(Buffer Pool Flush) 
MySQL 5.6 버전까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽게 처리되지 않 았다. 예를 들어, 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았다. 하지만 MySQL 5.7 버전을 거쳐서 MySQL 8.0 버전으로 업그레이드되면서 대부분의 서비스에서는 더티 페이지를 디스크에 동기화하는 부분(더티 페이지 플러시)에서 예전과 같은 디스크 쓰기 폭증 현상은 발생하지 않았다. 여기서 InnoDB 스토리지 엔진의 더티 페이지의 디스크 쓰기 동기화와 관련된 시스템 설정을 살펴보겠지만 **특별히 서비스를 운영할 때 성능 문제가 발생하지 않는 상태라면 굳이 이 시스템 변수들을 조정할 필요는 없다.** 

InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 **2개의 플러시 기능을 백그라운드로 실행**한다.

#### 플러시 리스트 플러시
InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야 한다. 그런데 이때 **오래된 리두 로그 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화**돼야 한다. 이를 위해 InnoDB 스토리지 엔진은 주기적으로 **플러시 리스트(Flush list) 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.** 이때 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자의 퀴리 처리가 악영향을 받지 않으면서 부드럽게 처리된다. 이를 위해 InnoDB 스토리지 엔진은 다음과 같은 시스템 변수들을 제공한다. 
- innodb_page_cleaners 
- innodb_max\_dirty_pages_pct_lwm 
- innodb\_max\_dirty_pages_ _pct 
- innodb\_io_capacity 
- innodb_io_capacity_max 
- innodb_flush_neighbors 
- innodb\_adaptive_flushing 
- innodb\_adaptive\_flushing_lwm 

InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드(Cleaner Thread)라고 하는데, `innodb_page_cleaners` 시스템 변수는 클리너 스레드의 개수를 조정할 수 있게 해준다. InnoDB 스토리지 엔진은 여러 개의 InnoDB 버퍼 풀 인스턴스를 동시에 사용할 수 있는데, `innodb_page_cleaners` 설정값이 버퍼 풀 인스턴스 개수보다 많은 경우에는 `innodb_buffer_pool_instances` 설정값으로 자동으로 변경한다. 즉, **하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하도록 자동으로 맞춰준다.** 하지만 `innodb_page_cleaners` 시스템 변수의 설정값이 버퍼 풀 인스턴스 개수보다 적은 경우에는 **하나의 클리너 스레드가 여러 개의 버퍼 풀 인스턴스를 처리**한다. 따라서 **가능하면 `innodb_page_cleaners` 설정값은 `innodb_buffer_pool_instances` 설정값과 동일한 값으로 설정하자.**

InnoDB 버퍼 풀은 클린 페이지뿐만 아니라 사용자의 DML(INSERT, UPDATE, DELETE)에 의해 변경된 더티 페이지도 함께 가지고 있다. 여기서 InnoDB 버퍼 풀은 **한계가 있기 때문에 무한정 더티 페이지를 그대로 유지할 수 없다**. 기본적으로 InnoDB 스토리지 엔진은 전체 버퍼 풀이 가진 페이지의 90%까지 더티 페이지를 가질 수 있는데, 때로는 이 값이 너무 높을 수도 있다. 이런 경우에는 `innodb_max_dirty_pages_pct`라는 시스템 설정 변수를 이용해 더티 페이지의 비율을 조정할 수 있다. **일반적으로 InnoDB 버퍼 풀은 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링함으로써 여러 번의 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다**. 그래서 `innodb_max_dirty_pages_pct` 시스템 설정은 가능하면 기본값을 유지하는 것이 좋다. 

#### 디스크 쓰기 폭발 예방
여기서 한 가지 더 문제점이 발생하는데, InnoDB 버퍼 풀에 **더티 페이지가 많으면 많을수록 디스크 쓰기 폭발(Disk IO Burst) 현상이 발생할 가능성이 높아진다.** InnoDB 스토리지 엔진은 `innodb_io_capacity` 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행한다. 하지만 디스크로 기록되는 더티 페이지 개수보다 더 많은 더티 페이지가 발생하면 버퍼 풀에 더티 페이지가 계속 증가하게 되 고, 어느 순간 더티 페이지의 비율이 90%를 넘어가면 InnoDB 스토리지 엔진은 급작스럽게 더티 페이지를 디스크로 기록해야 한다고 판단한다. 그래서 급작스럽게 디스크 쓰기가 폭증하는 현상이 발생한다. 이런 문제를 완화하기 위해 InnoDB 스토리지 엔진에서는 `innodb_max_dirty_pages_pct_lam`이라는 시스템 설정 변수를 이용해 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하고 있다. `innodb_max_dirty_pages_pct_lam` 시스템 변수의 기본값은 10% 수준인데, 만약 더티 페이지의 비율이 얼마 되지 않는 상태에서 디스크 쓰기가 많이 발생하고 더티 페이지의 비율이 너무 낮은 상태로 계속 머물러 있다면 `innodb_max_dirty_pages_pct_lam` 시스템 변수를 조금 더 높은 값으로 조정하는 것도 디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다. 

`innodb_io_capacity`와 `innodb_io_capacity_max` 시스템 변수는 각 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지를 설정하는 값이다. **`innodb_io_capacity`는 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값을 설정**하며, **`innodb_io_capacity_max` 시스템 변수는 디스크가 최대의 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지를 설정**한다. **여기서 언급하는 디스크 읽고 쓰기란 InnoDB 스토리지 엔진의 백그라운드 스레드가 수행하는 디스크 작업을 의미**하는데, 대부분 InnoDB 버퍼 풀의 더티 페이지 쓰기가 이에 해당한다. 하지만 InnoDB 스토리지 엔진은 사용자의 쿼리를 처리하기 위해 디스크 읽기도 해야 한다. 그래서 현재 장착된 디스크가 초당 1000 IOPS를 처리 할 수 있다고 해서 이 값을 그대로 `innodb_io_capacity`와 `innodb_io_capacity_max` 시스템 변수에 설정해서는 안 된다.

> `innodb_io_capacity`와 `innodb_io_capacity_max` 시스템 변수에 1000을 설정한다고 해서 초당 1000번의 디스크 쓰기를 보장하는 것은 아니다. InnoDB 스토리지 엔진은 내부적인 최적화 알고리즘을 가지고 있어서 설정된 값 들을 기준으로 적당히 계산된 횟수만큼 더티 페이지 쓰기를 하기 때문이다. 그래서 `innodb_io_capacity`와 `innodb_io_capacity_max` 시스템 변수를 설정하고, 어느 정도 디스크 쓰기를 하는지 관찰하면서 분석하고 패턴을 익하는 것이 중요하다. 

#### 어댑티브 플러시
관리해야 할 MySQL 서버가 많다면 일일이 서버의 트래픽을 봐 가면서 `innodb_io_capacity`와 `innodb_io_capacity_max`를 설정하는 것은 상당히 번거로운 일이 될 것이다. 그래서 InnoDB 스토리지 엔진은 어댑티브 플러시(Adaptive flush)라는 기능을 제공한다. 어댑티브 플러시는 `innodb_ adaptive_flushing` 시스템 변수로 켜고 끌 수 있는데, 기본값은 어댑티브 플러시를 사용하는 것이다. 어댑티브 플러시 기능이 활성화되면 InnoDB 스토리지 엔진은 단순히 버퍼 풀의 더티 페이지 비율이나 `innodb_io_capacity`, `innodb_io_capacity_max` 설정값에 의존하지 않고 새로운 알고리즘을 사용한다. 더티 페이지를 어느 정도 디스크로 기록해야 할지는 사실 어느 정도 속도로 더티 페이지가 생성되는지를 분석하는 것인데, 이는 결국 리두 로그가 어느 정도 속도로 증가하는 지를 분석하는 것과 같다. 그래서 **어댑티브 플러시 알고리즘은 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행한다.** `innodb_adaptive_flushing_lwm` 시스템 변수의 기본값은 10%인데, 이는 전체 리두 로그 공간에서 활성 리두 로그의 공간이 10% 미만이면 어댑티브 플러시가 작동하지 않다가 10%를 넘어서면 그때부터 어댑티브 플러시 알고리즘이 작동하게 한다. 


#### Neighbors(Locality) flush
마지막으로 **`innodb_flush_neighbors` 시스템 변수는 더티 페이지를 디스크에 기록할 때 디스크에서 근접 한 페이지 중에서 더티 페이지가 있다면 InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해주는 기능을 활성화할지 결정한다.** 예전에 많이 사용하던 하드디스크(HDD)의 경우 디스크 읽고 쓰기는 매우 고비용의 작업이었다. 그래서 많은 데이터베이스 서버들은 한 번이라도 디스크 읽고 쓰기를 줄 이기 위해 많은 노력을 기울였는데, 이웃 페이지들의 동시 쓰기(`innodb_ _flush_neighbors`)는 그러한 노력의 결과라고 볼 수 있다. 데이터 저장을 하드디스크로 하고 있다면 `innodb_flush_neighbors` 시스템 변수 를 1 또는 2로 설정해서 활성화하는 것이 좋다. 하지만 요즘은 대부분 솔리드 스테이트 드라이브(SSD)를 사용하기 때문에 기본값인 비활성 모드로 유지하는 것이 좋다.

#### LRU 리스트 플러시
InnoDB 스토리지 엔진은 LRU 리스트에서 **사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU 리스트(`LRU_list`) 플러시 함수가 사용**된다. InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 `innodb_lru_scan_depth` 시스템 변수에 설정된 개수만큼의 페이지들을 스캔한다. InnoDB 스토리지 엔진은 이때 스캔하면서 더티 페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 프리(Free) 리스트로 페이지를 옮긴다. InnoDB 스토리지 엔진은 InnoDB 버퍼 풀 인스턴스별로 최대 `innodb_lru_scan_depth` 개수만큼 스캔하기 때문에 실질적으로 LRU 리스트의 스캔은 (`innodb_buffer_pool_instances` * `innod_lru_scan_depth`) 수만큼 수행한다.

