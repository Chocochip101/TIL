
## B-Tree 인덱스의 가용성과 효율성
퀴리의 WHERE 조건이나 GROUP BY, 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다. 그래야만 쿼리의 조건을 최적화하거나, 역으로 퀴리에 맞 게 인덱스를 최적으로 생성할 수 있다. 어떤 조건에서 인덱스를 사용할 수 있고 어떨 때 사용 할 수 없는지 살펴보겠다. 또한 인덱스를 100% 활용할 수 있는지, 일부만 이용하게 되는지도 함께 살펴본다. 

### 비교 조건의 종류와 효율성
다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교("=")인지 아니면 크다(">") 또는 작다("<") 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다. 다음 예제를 한번 살펴보자.

```sql
mysql> SELECT * FROM dept_emp WHERE dept_no='d002' AND emp_no >= 10114; 
```

이 쿼리를 위해 `dept_emp` 테이블에 각각 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성했다고 가정하자. 위의 쿼리가 처리되는 동안 각 인덱스에 어떤 차이가 있었는지 살펴보자.

- 케이스 A: INDEX (dept_no, emp_no)
- 케이스 B: INDEX (emp_no, dept_no)

케이스 A 인데스는 "`dept_no`= 'd002' AND `emp_no`>=10144"인 레코드를 찾고, 그 이후에는 `dept_no`가 'd002' 가 아닐 때까지 인덱스를 그냥 쪽 읽기만 하면 된다. 이 경우에는 읽은 레코드가 모두 사용자가 원하는 결과임을 알 수 있다. 즉, 조건을 만족하는 레코드가 5건이라고 할 때, 5건의 레코드를 찾는데 꼭 필요한 5번의 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스를 이용한 것이다. 하지만 케이스 B 인데스는 우선 "`emp_no`>=10144 AND `dept_no`= 'd002'"인 레코드를 찾고, 그 이후 모든 레코드에 대해 `dept_no`가 'd002'인지 비교하는 과정을 거쳐야 한다. 그림 8.17은 두 인덱스의 검색 과정을 보여준다. 

![](https://velog.velcdn.com/images/chocochip/post/c32c28b3-3815-4198-978f-3e75b49be0e0/image.jpg)

이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 '필터링' 이라고도 한다. 케이스 B 인덱스에서는 최종적으로 `dept_no`= 'd002' 조건을 만족(필터링)하는 레코드 5 건을 가져온다. 즉, 이 경우에는 5건의 레코드를 찾기 위해 7번의 비교 과정을 거친 것이다. 왜 이런 현상이 발생했을까? 그 이유는 그림 8.13 '다중 칼럼 인덱스'에서 설명한 다중 칼럼 인덱스의 정렬 방식 (인덱스의 N번째 키 값은 N-1번째 키 값에 대해서 다시 정렬됨) 때문이다. 케이스 A 인덱스에서 2번 째 칼럼인 `emp_no`는 비교 작업의 범위를 좁히는 데 도움을 준다. 하지만 케이스 B 인덱스에서 2번째 칼럼인 `dept_no`는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용됐다.

#### 작업 범위 결정 조건과 필터링 조건
공식적인 명칭은 아니지만 케이스 A 인덱스에서의 두 조건(`dept_no`='d002'와 `emp_no`>=10144)과 같이 **작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'**이라 하고, 케이스 B 인덱스의 `dept_no`='d002' 조건과 같이 **비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'**이라고 표현한다. 결국, 케이스 A 인덱스에서 `dept_no` 칼럼과 `emp_no` 칼럼은 모두 '작업 범위 결정 조건'에 해당하지만, 케이스 B 인덱스에서는 `emp_no` 칼럼만 '작업 범위 결정 조건'이고, `dept_no` 칼럼은 '필터링 조건'으로 사용된 것이다. 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 (최종적으로 가져오는 레코드는 작게 만들지 몰라도) 퀴리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.

### 인덱스의 가용성
B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 (Left-most) 오른쪽 값이 정렬돼 있다는 것이다. 여기서 왼쪽이란 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용된다. 
- 케이스 A: INDEX (first_name) 
- 케이스 B: INDEX (dept_no, emp_no) 

그림 8.18에서는 인덱스 키 값의 정렬만 표현하지만 사실은 인덱스 키 값의 이런 정렬 특성은 빠른 검색의 전제 조건이다. 즉 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능하다. 또한 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다. 

케이스 A의 인덱스가 지정된 employees 테이블에 대해 다음과 같은 쿼리가 어떻게 실행되는지 한번 살 펴보자.

![](https://velog.velcdn.com/images/chocochip/post/aa1c2a22-ea26-4272-a380-f3aa8e6d7043/image.jpg)

```sql
mysql> SELECT * FROM employees WHERE first_name LIKE '%mer'; 
```
이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수는 없다. 그 이유는 `first_name` 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값 (`%mer`)에는 왼쪽 부분이 고정되지 않았기 때문이다. 따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 왼쪽 기준(Left-most) 정렬 기반의 인덱스인 B-tree에서는 인덱스의 효과를 얻을 수 없다. 케이스 B의 인덱스가 지정된 `dept_emp` 테이블에 대해 다음 쿼리가 어떻게 실행되는지 한번 살펴보자.

```sql
mysql> SELECT * FROM dept_emp WHERE emp_no>=10144; 
```
인덱스가 (`dept_no`, `emp_no`) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 `dept_no` 조건 없이 `emp_no` 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다. 케이스 B의 인덱스는 다중 칼럼으로 구성된 인덱스이므로 `dept_no` 칼럼에 대해 먼저 정렬한 후, 다시 `emp_no` 칼럼값으로 정렬돼 있기 때문이다. 여기서는 간단히 WHERE 조건절에 대한 내용만 언급했지만 인덱스의 왼쪽 값 기준 규칙은 GROUP BY 절이나 ORDER BY 절에도 똑같이 적용된다. GROUP BY나 ORDER BY에 대해서는 나중에 다시 자세히 살펴보겠다.

### 가용성과 효율성 판단
기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미하며, 경우에 따라서는 체크 조건으로 인덱스를 사용할 수는 있다. 

- NOT-EQUAL로 비교된 경우("<>", "NOT IN". "NOT BETWEEN", "IS NOT NULL")
  - .. WHERE column <> 'N'
  - .. WHERE column NOT IN (10,11,12)
  - .. WHERE column IS NOT NULL
- LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
  - .. WHERE column LIKE '%승환'
  - .. WHERE column LIKE '\_승환'
  - .. WHERE column LIKE '%승용%'
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우 
  - .. WHERE SUBSTRING(column, 1,1) = 'X' 
  - .. WHERE DAYOFMONTH(column) = 1
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - .. WHERE column = deterministic* function()
- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우) 
  - .. WHERE char_column = 10
- 문자열 데이터 타입의 콜레이션이 다른 경우 
  - .. WHERE utf8_bin_char_column = euckr_bin_char_column
  
다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다.  다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.
```sql
mysql> .. WHERE column IS NULL ..
```
다중 칼럼으로 만들어진 인덱스는 어떤 조건에서 사용될 수 있고, 어떤 경우에 절대 사용할 수 없는지 살펴보자. 다음과 같은 인덱스가 있다고 가정해 보자. 
```
INDEX ix_test ( column_1, column_2, column_3, ..., column_n ) 
```
- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - `column_1` 칼럼에 대한 조건이 없는 경우
  - `column_1` 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)
  - `column_1` ~ `column_(i-1)` 칼럼까지 동등 비교 형태("=" 또는 "IN")로 비교
  - `column_i` 칼럼에 대해 다음 연산자 중 하나로 비교 
    - 동등 비교("=" 또는 "IN") 
    - 크다 작다 형태(">" 또는 "<")
    - LIKE로 좌측 일치 패턴(LIKE '승환%') 
    
위의 두 가지 조건을 모두 만족하는 쿼리는 `column_1`부터 `column_i`까지는 작업 범위 결정 조건으로 시용 되고, `column_(i+1)`부터 `column_n`까지의 조건은 체크 조건으로 사용된다. 인덱스를 사용하는 경우와 그 렇지 않은 상황에 해당하는 쿼리의 조건 몇 가지를 예제로 살펴보자.

```sql
--// 다음 쿼리는 인덱스를 사용할 수 없음 
mysql> .. WHERE column_1 <> 2 

-- // 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨 
mysql> .. WHERE column_1 = 1 AND column_2 > 10

-- // 다음 쿼리는 column_1, column_2, column_3까지 범위 결정 조건으로 사용됨 
mysql> .. WHERE column_1 IN (1,2) AND column_2 = 2 AND column_3 <= 10

-- // 다음 쿼리는 column_1, column_2, column_3까지 범위 결정 조건으로,
-- // colum_4는 체크 조건으로 사용됨 
mysql> .. WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10,20,30) AND column_4 ◇ 100 

-- // 다음 쿼리는 column_1, column_2, column_3, column_4까지 범위 결정 조건으로 사용됨 
-- // 좌측 패턴 일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각하면 됨 

mysql> .. WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 30 AND colum_4 LIKE '김승%'

-- // 다음 쿼리는 column_1, column_2, column_3, column_4, colum_5 칼럼까지 
-- // 모두 범위 결정 조건으로 사용됨
mysql>.. WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30 AND column_4 = '김승환' AND column_5 = '서울' 
```

작업 범위 결정 조건으로 인덱스를 사용하는 쿼리 패턴은 이 밖에도 상당히 많이 있겠지만, 대표적 인 것을 기억해 두면 좀 더 효율적인 쿼리를 쉽게 작성할 수 있다. 또한 여기서 설명하는 내용은 모두 B-Tree 인덱스의 특징이므로 MySQL뿐 아니라 대부분의 RDBMS에도 동일하게 적용된다. 

# R-Tree 인덱스
공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다. 기본적인 내부 메커니즘은 B-Tree와 흡사하다. B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값이라는 것이다. 최근 GPS나 지도 서비스를 내장하는 스마트 폰이 대중화되면서 SNS 서비스가 GIS와 GPS에 기반 을 둔 서비스로 확장되고 있다. 이러한 위치 기반의 서비스를 구현하는 방법은 여러 가지가 있겠지만 MySQL의 공간 확장(Spatial Extension)을 이용하면 간단하게 이러한 기능을 구현할 수 있다. MySQL의 공간 확장에는 다음과 같이 크게 세 가지 기능이 포함돼 있다.

- 공간 데이터를 저장할 수 있는 데이터 타입 
- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리) 



# 전문 검색 인덱스

# 함수 기반 인덱스
때로는 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있는데 이러한 경우 함수 기반의 인덱스를 활용하면 된다. MySQL 8.0 버전부터 함수 기반 인덱스를 지원하기 시작했는데 MySQL 서버에서 함수 기반 인덱스를 구현하는 방법은 다음과 같이 두 가지로 구분할 수 있다.

- 가상 컬럼을 이용한 인덱스
- 함수를 이용한 인덱스

MySQL 서버의 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다.

## 가상 컬럼을 이용한 인덱스
다음과 같이 사용자 정보를 저장하는 테이블이 있다고 가정해보자.

```sql
mysql> CREATE TABLE user (
		user_id BIGINT,
        first_name VARCHAR(10),
        last_name VARCHAR(10),
        PRIMARY KEY (user_id)
      );
 ```
그런데 `first_name`과 `last_name`을 합쳐서 검색해야 하는 요건이 생겼다면 가상 컬럼을 추가하고 그 가상 컬럼에 대한 인덱스를 생성할 수 있다.
```sql
mysql> ALTER TABLE user
		ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ', last_name)) VIRTUAL,
        ADD INDEX ix_fullname (full_name);
```
이제부터는 full_name 컬럼에 대한 검색도 새로 만들어진 `ix_fullname` 인덱스를 이용해 실행 계획이 만들어지는 것을 확인할 수 있다. 가상 컬럼이 VIRTUAL이나 STORED 옵션 중 어떤 옵션으로 생성됐든 관계없이 해당 컬럼에 인덱스를 생성할 수 있다. 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.

## 함수를 이용한 인덱스
MySQL 8.0 버전부터는 다음과 같이 테이블의 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 사용할 수 있게 되었다.

```sql
mysql> CREATE TABLE user (
		user_id BIGINT,
        first_name VARCHAR(10),
        last_name VARCHAR(10),
        PRIMARY KEY (user_id),
        INDEX ix_fullname ((CONCAT(first_name,' ',last_name))
      );
      
```
함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고 계산된 결과값의 검색을 빠르게 만들어준다. 함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식 그대로 사용돼야 한다. 함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식이 다르다면 MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못한다.


# 멀티 밸류 인덱스
Full Text search 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다. 하지만 멀티 밸류(Multi-Value) 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다. 일반적인 RDBMS를 기준으로 생각하면 이러한 인덱스는 정규화에 위배되는 형태다. 하지만 최근 RDMBS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.
