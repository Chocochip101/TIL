## 트랜잭션 지원 메타데이터

### 기존 파일 기반의 메타데이터 관리의 문제점
DB 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라 하는데, MySQL 서버 5.7 버전까지 테이블의 구조를 FRM 파일에 저장하고 이룹 스토어브 프로그램 또한 파일(\*.TRN, \*.TRG, ...) 기반으로 관리했다. 하지만 이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되며 일관되지 않은 상태로 남는 문제가 있었다.

### 트랜잭션 지원 메타데이터
MySQL 8.0 버전부터는 이러한 문제점을 해결하기 위해 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 InnoDB의 테이블에 저장하도록 개선했다. **MySQL 서버가 작동하는데 기본적으로 필요한 테이블들을 묶어서 시스템 테이블**이라고 하는데, 대표적으로 사용자의 인증과 권한에 관련된 테이블들이 있다. MySQL 서버 8.0 버전부터는 이런 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선했으며, 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있다. mysql DB는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장된다. 그래서 MySQL 서버 의 데이터 디렉터리에 존재하는 mysql. ibd라는 파일은 다른 \*.ibd 파일과 함께 특별히 주의해야한다. 

메타 정보가 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되므로 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료되단고 하더라도 스키마 변경이 완전히 성공 또는 실패로 정리된다. 기존의 작업 중간 상태로 남지 않는 것이다.

> MyISAM 같은 경우는 여전히 메타 정보를 저장할 공간이 필요하므로, SDI(Serialized Dictionary Information) 파일을 사용한다.

# InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이고 성능이 뛰어나다.

![](https://velog.velcdn.com/images/chocochip/post/e3feee0f-bf3c-4d9a-aea7-1e8ccbd39b2a/image.png)

## PK에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다. 즉, **PK 값의 순서대로 저장**된다는 뜻이며, **모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용한다.** PK가 클러스터링 인덱스이기 때문에 PK를 이용한 **Range Scan은 상당히 빨리 처리**될 수 있다. 결과적으로 쿼리의 실행 계획에서 PK는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.

> 비중이 높다는 것은 퀴리의 실행 계획에서 다른 보조 인덱스보다 PK가 선택될 확률이 높다.

### MyISAM에서의 클러스터링
InnoDB 스토리지 엔진과 달리 MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다. 따라서 MyISAM 테이블에서는 PK와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다. PK는 유니크 제약조건을 가진 세컨더리 인덱스일 뿐이다. 그리고 MyISAM 테이블의 PK를 포함한 모든 인덱스는 물리적인 레코드의 주소 값을 가진다. 

## 외래 키 지원
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 **MyISAM이나 MEMORY 테이블에서는 사용할 수 없다**. 외래 키는 DB 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 **개발 환경의 DB에서는 좋은 가이드 역할을 할 수 있다.** InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.


### 외래 키 무결성 검사 해제
수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다. 물론 부모 테이블과 자식 테이블의 관계를 명확히 파악해서 순서대로 작업한다면 문제 없이 실행할 수 있지만 외래 키가 복잡하게 얽힌 경우 간단하지 않다. 이런 경우 `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. 외래 키 체크 작업을 일시적으로 멈추면 대략 레코드의 적재나 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 **훨씬 빠르게** 처리할 수 있다.

외래 키 체크를 일시적으로 해제했다고 해서 부모, 자식 테이블 간의 관계가 깨진 상태로 유지해도 된다는 것을 의미하지 않는다. 반드시 일관성을 맞춰준 후에 외래 키 체크 기능을 활성화 해야 한다.

