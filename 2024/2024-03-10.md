## B-Tree 인덱스를 통한 데이터 읽기
어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL 스토리지 엔진이 어떻게 인덱스를 이용해서 실제 레코드를 읽어 내는지 알아야 한다. MySQL이 인덱스를 이용하는 대표적인 방법 세 가지를 살펴보겠다.

### 인덱스 레인지 스캔
인덱스 레인지 스캔은 인덱스의 접근 방법 가운데 가장 대표적인 접근 방식으로, 뒤에서 설명할 나머지 두 가지 접근 방식보다는 빠른 방법이다. 인덱스를 통해 레코드를 **한 건만 읽는 경우**와 **한 건 이상을 읽는 경우**를 각각 다른 이름으로 구분하지만, 이번 절에서는 모두 묶어서 "인덱스 레인지 스캔"이라고 표현했다. 여기서는 인덱스 B-Tree의 필요한 영역을 스캔하는 데 어떤 작업이 필요한지만 이해할 수 있으면 충분하다. 다음 쿼리를 예제로 살펴보자. 

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

![](https://velog.velcdn.com/images/chocochip/post/ca286809-602d-4864-8c95-2964a71c3711/image.jpg)

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다. 위 그림의 화살표에서도 알 수 있듯이 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 **필요한 레코드의 시작 지점**을 찾을 수 있다. 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다. 이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다. 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다. 그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용 자에게 반환하고 쿼리를 끝낸다. 그림에서 두꺼운 선은 스캔해야 할 위치 검색을 위한 비교 작업을 의미하며, 두꺼운 화살표가 지나가는 리프 노드의 레코드 구간은 실제 스캔하는 범위를 표현한다. 그림은 실제 인덱스만을 읽는 경우를 보여준다. 하지만 B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데, 이 과정을 좀 더 자세히 살펴보자.


![](https://velog.velcdn.com/images/chocochip/post/7bbbf997-96fb-4542-857d-4442d322d74e/image.jpg)

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나가는 과정을 그림 8.9에서 확인할 수 있다. 중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것이다. 이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다. 그림에서 또 한 가지 중요한 것은 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 **데이터 파일에서 레코드를 읽어오는 과정이 필요**하다는 것이다. 이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다. 그림처럼 3건의 레코드가 검색 조건에 일치했다고 가정하면, 데이터 레코드를 읽기 위해 랜덤 I/O가 최대 3번 필요한 것이다. 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다. 그리고 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다. 인덱스 레인지 스캔은 다음과 같이 크게 3단계를 거친다는 점을 살펴봤다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색(index seek)이라고 한다. 
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔(index scan)이라고 한 다. (1번과 2번 합쳐서 인덱스 스캔으로 통칭하기도 한다.) 
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다. 

**쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다.** 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다. MySQL 서버에서는 1번과 2번 단계의 작업이 얼마나 수행됐는지를 확인할 수 있게 다음과 같은 상태 값을 제공한다. 

```sql
mysql> SHOW STATUS LIKE 'Handler%';

| Variable_name			| Value 	| 
| Handler_read_first	| 71 		| 
| Handler_read_last 	| 1 		|
| Handler_read_key 		| 567 		|
| Handler_read_next 	| 3447233 	|
| Handler_read_prev 	| 19 		|
```
- `Handler_read_key`: 1번 단계가 실행된 횟수
- `Handler_read_next`: 2번 단계로 읽은 레코드 건수 중 인덱스 정순으로 읽은 레코드 건수
- `Handler_read_prev`: 2번 단계로 읽은 레코드 건수 중 인덱스 역순으로 읽은 레코드 건수
- `Handler_read_first`, `Handler_read_last`: 인덱스의 첫 번째 레코드와 마지막 레코드를 읽은 횟수를 의미하는데, 이 둘은 MIN() 또는 MAX() 와 같이 제일 큰 값 또는 제일 작은 값만 읽는 경우 증가하는 상태 값이다.

> 실제 인덱스만 읽었는지 인덱스를 통해 테이블의 레코드를 읽었는지(3번 단계)는 구분하지 않는다.


### 인덱스 풀 스캔

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 **인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.** 대표적으로 퀴리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. 예를 들어, 인덱스는 (A, B, C) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우다. 

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다. **쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.** 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

![](https://velog.velcdn.com/images/chocochip/post/63782988-1c56-4871-b99a-45877741a370/image.jpg)

그림 8.10에서 인덱스 풀 스캔의 예를 살펴볼 수 있다. 먼저 인덱스 리프 노드의 제일 앞 또는 제일 뒤 로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트(Linked list, 리프 노드 사이를 연결하는 세로로 그려진 두 쌍의 화살표)를 따라서 처음부터 끝까지 스캔하는 방식을 인덱스 풀 스캔이라고 한다. 이 방식은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. **앞에서도 언급했듯이 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다. 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이 블 전체를 읽는 것보다는 적은 디스크 I/O로 퀴리를 처리할 수 있다.**

> 여기서 특별히 방식을 언급하지 않고 "인덱스를 사용한다"라고 표현한 것은 "인덱스 레인지 스캔"이나 뒤에서 설명할 "루스 인덱스 스캔" 방식으로 인덱스를 사용한다는 것을 의미한다. 인덱스 풀 스캔 방식 또한 인덱스를 이용 하는 것이지만 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적은 아니다. 역으로 테이블 전체를 읽거나 인덱스 풀 스캔 방식으로 인덱스를 사용하는 경우는 "인덱스를 사용하지 못한다" 또는 "인덱스를 효율적으로 사용하지 못한다"라는 표현을 사용했다. 

### 루스 인덱스 스캔
오라클 DBMS의 "인덱스 스킵 스캔"이 라고 하는 기능과 작동 방식은 비슷하지만 MySQL에서는 이를 "루스 인덱스 스캔"이라고 한다. MySQL 5.7 버전까지는 MySQL의 루스 인덱스 스캔 기능이 많이 제한적이 었지만, MySQL 8.0 버전부터는 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 조금씩 지원하기 시작했다. 앞에서 소개한 두 가지 접근 방법("인덱스 레인지 스캔"과 "인덱스 풀 스캔")은 "루스 인덱스 스캔"과는 상반된 의미에서 "타이트(Tight) 인덱스 스캔"으로 분류한다. 루스 인덱스 스캔 이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

![](https://velog.velcdn.com/images/chocochip/post/baaf3661-f671-4cc4-8fa9-327affb63973/image.png)

루스 인데스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다. 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다. 

```sql
SELECT dept_no, MIN(emp_no) 
FROM dept_emp 
WHERE dep_no BETWEEN 'd992' AND 'd004' 
GROUP BY dept_no; 
```

이 쿼리에서 사용된 `dept_emp` 테이블은 `dept_no`와 `emp_no`라는 두 개의 칼럼으로 인덱스가 생성돼 있다. 또한 이 인데스는 (`dept_no`, `emp_no`) 조합으로 정렬까지 돼 있어서 그림 8.11에서와 같이 `dept_no` 그룹 별로 첫 번째 레코드의 `emp_no` 값만 읽으면 된다. 즉 인덱스에서 WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다. 그림 8.11을 보면 인덱스 리프 노드를 스캔하면서 불필요한 부분은 그냥 무시하고 필요한 부분(회색 바탕 색깔의 레코드)만 읽었음을 알 수 있다. 루스 인덱스 스캔을 사용하려면 여러 가지 조건을 만족해야 하는데, 이러한 제약 조건은 '실행 계획'에서 자세히 언급한다.

### 인덱스 스킵 스캔
데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다. 예를 들어, employees 테이블에 다음과 같은 인덱스를 생성해보자. 

```sql
mysql> ALTER TABLE employees 
ADD INDEX ix_gender_birthdate (gender, birth_date); 
```
이 인덱스를 사용하려면 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수다.

```sql
-- // 인덱스를 사용하지 못하는 쿼리 
mysql> SELECT * FROM employees WHERE birth_date>= '1965-02-01';

--// 인덱스를 사용할 수 있는 쿼리 
mysql> SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
```

그래서 위의 두 쿼리 중에서 `gender` 칼럼과 `birth_date` 칼럼의 조건을 모두 가진 두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있지만 `gender` 칼럼에 대한 비교 조건이 없는 첫 번째 쿼리는 인덱스를 사용할 수가 없었다. 주로 이런 경우에는 `birth_date` 칼럼부터 시작하는 인덱스를 새로 생성해야만 했다. 

MySQL 8.0 버전부터는 옵티마이저가 `gender` 칼럼을 건너뛰어서 `birth_date` 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔(Index skip scan) 최적화 기능이 도입됐다. 물론 MySQL 8.0 이전 버전에서도 인덱스 스킵 스캔과 비슷한 최적화를 수행하는 루스 인데스 스캔(Loose index scan) 이라는 기능이 있었지만 루스 인덱스 스캔은 **GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용**할 수 있었다. 하지만 MySQL 8.0 버전에 도입된 **인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨씬 넓어진 것이다.**

우선 인덱스 스킵 스캔 기능을 비활성화하고, MySQL 8.0 이전 버전에서 어떤 실행 계획으로 처리됐는지를 한 번 살펴보자.

```sql
mysql> SET optimizer_switch='skip_scan=off';

mysql> EXPLAIN 
		SELECT gender, birth_ date 
        FROM employees 
        WHERE birth_date>=' 1965-02-01'; 
        
| id	| table	 	| type		 | key					 |Extra		 |
| 1 	| employees | index 	| ix_gender_birthdate 	| Using where; Using index|
```

위의 쿼리는 WHERE 조건절에 `gender` 칼럼에 대한 조건 없이 `birth_date` 칼럼의 비교 조건만 가지고 있기 때문에 쉽게 `ix_gender_birthdate` 인덱스를 효율적으로 이용할 수 없다. 위의 실행 계획에서 type 칼럼이 "index"라고 표시된 것은 인덱스를 처음부터 끝까지 모두 읽었다(풀 인덱스 스캔)는 의미이므로 인덱스를 비효율적으로 사용한 것이다. 이 예제 쿼리는 인덱스에 있는 gender 칼럼과 `birth_date` 칼럼만 있으면 처리를 완료할 수 있기 때문에 `ix_gender_ birthdate` 인덱스를 풀 스캔한 것이다. 만약 예제 퀴리가 employees 테이블의 모든 칼럼을 가져와야 했다면 테이블 풀 스캔을 실행했을 것이다.

이제 MySQL 8.0 버전부터 도입된 인덱스 스킵 스캔을 활성화하고, 동일 쿼리의 실행 계획을 다시 확인해보자. 

```sql
mysql> SET optimizer_switch='skip_scan=on'

mysql> EXPLAIN SELECT gender, birth_date FROM employees WHERE birth_ date>=' 1965-02-01'; / id I table I type I key I Extra I 1 I employees I range I ix_gender_ birthdate I Using where; Using index for skip scan 
```

이번에는 퀴리의 실행 계획에서 type 칼럼의 값이 "range"로 표시됐는데, 이는 인덱스에서 꼭 필요한 부분만 읽었다는 것을 의미한다. 그리고 실행 계획의 Extra 칼럼에 "Using index for skip scan"이라 는 문구가 표시됐는데, 이는 ix_gender_birthdate 인덱스에 대해 인덱스 스킵 스캔을 활용해 데이터를 조회했다는 것을 의미한다. MySQL 옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해 서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다. 다음의 그림 8.12는 인덱스 스킵 스캔이 어떻게 처리되는지를 보여준다.

![](https://velog.velcdn.com/images/chocochip/post/9b933b00-a01b-479a-9df6-9fe6b64c5e38/image.jpg)

gender 칼럼은 성별을 구분하는 칼럼으로 'M'과 'F' 값만 가지는 ENUM 타입의 칼럼이다. 그래서 gender 칼럼에 대해 가능한 값 2개('M'과 'F')를 구한 다음, 옵티마이저는 내부적으로 아래 2개의 쿼리를 실행 하는 것과 비슷한 형태의 최적화를 실행하게 된다. 
```sql
mysql> SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date>=' 1965-92-01'; mysql> SELECT gender, birth_date FROM employees WHERE gender='F' AND birth_date>='1965-02-01'; 
```
>여기서 gender 칼럼이 ENUM('M' 'F') 타입이기 때문에 이런 처리가 가능한 것은 아니다. 칼럼이 타입이 더라도 MySQL 서버는 인덱스를 루스 인덱스 스캔과 동일한 방식으로 읽으면서 인덱스에 존재하는 모든 값을 먼저 추 출하고 그 결과를 이용해 인덱스 스킵 스캔을 실행한다. 


인덱스 스킵 스캔은 MySQL 8.0 버전에 새로이 도입된 기능이어서 아직 다음과 같은 단점이 있다.
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함 
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스) 

첫 번째 조건은 쿼리 실행 계획의 비용과 관련된 부분인데, 만약 유니크한 값의 개수가 매우 많다면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다. 그래서 퀴리의 처리 성능이 오히려 더 느려질 수도 있다. 예를 들어 (emp_no, dept_no) 조합으로 만들어진 인덱 스에서 스킵 스캔을 실행한다고 가정하면 사원의 수만큼 레인지 스캔 시작 지점을 검색하는 작업이 필 요해져 퀴리의 성능이 매우 떨어진다. 그래서 인덱스 스킵 스캔은 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화라는 것을 기억하자. 

두 번째 제약 조건은 아래 예제 쿼리를 통해 한번 살펴보자. 
```sql
mysql> EXPLAIN SELECT FROM employees WHERE birth_ date>= 1965-02-01'; i id I table I type I key I rows I Extra - 1 I employees I ALL I NULL I 300363 I Using where -
```

위의 쿼리는 WHERE 조건절은 동일하지만 SELECT 절에서 employees 테이블의 모든 칼럼을 조회하도록 변 경했다. 이 쿼리는 `ix_gender_birthdate` 인덱스에 포함된 gender 칼럼과 `birth_date` 칼럼 이외의 나머지 칼럼도 필요로 하기 때문에 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔으로 실행 계획을 수립 한 것을 확인할 수 있다. 하지만 이 제약 사항은 MySQL 서버의 옵티마이저가 개선되면 충분히 해결될 수 있는 부분으로 보인다. 


