## Double Write Buffer

### 파셜 페이지(Partial-page)/톤 페이지(Torn -page) 문제
InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. **이로 인해 InnoDB의 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다**. 이렇게 **페이지가 일부만 기록 되는 현상을 파셜 페이지(Partial-page) 또는 톤 페이지(Torn -page)라고 하는데, 이런 현상은 하드 웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.** 

### Double-Write 기법
InnoDB 스토리지 엔진에서는 이 같은 문제를 막기 위해 Double-Write 기법을 이용한다. 아래 그림은 InnoDB의 Double-Write 기법이 작동하는 방식을 표현한 것이다. 그림에서와 같이 InnoDB에서 'A' ~ 'E'까지의 더티 페이지를 디스크로 플러시한다고 가정해보자. 이때 InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 'A' ~ 'E'까지의 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 Double Write 버퍼에 기록한다. 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다. 

![](https://velog.velcdn.com/images/chocochip/post/07e57376-1d80-4b7c-867c-8870b0c07219/image.jpg)

이렇게 시스템 테이블스페이스의 DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 'A' ~ 'E' 더티 페이지가 정상적으로 기록되면 더이상 필요가 없어진다. **DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.** 'A'와 'B' 페이지는 정상적 으로 기록됐지만 'C' 페이지가 기록되는 도중에 운영체제가 비정상적으로 종료됐다고 가정해보자. 그러 면 InnoDB 스토리지 엔진은 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들 을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다. DoubleWrite 기능을 사용할지 여부는 `innodb_doublewrite` 시스템 변수로 제어할 수 있다. 

### 용법
DoubleWrite 버퍼는 데이터의 안정성을 위해 자주 사용되는데, HDD처럼 자기 원판(Platter)이 회전 하는 저장 시스템에서는 어차피 한 번의 순차 디스크 쓰기를 하는 것이기 때문에 별로 부담이 되지 않지만 SSD처럼 **랜덤 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.** 하지만 데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite의 활성화를 고려하는 것이 좋다. 만약 데이 터베이스 서버의 성능을 위해 InnoDB 리두 로그 동기화 설정(`innodb_flush_log_at_trx_commit` 시스템 변수)을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화하는 것이 좋다.

> 일반적으로 MySQL 서버에서는 복제를 이용해 동일 데이터에 대해 여러 개의 사본을 유지하기 때문에 MySQL 서버가 비정상 종료되면 버리고 바이너리 로그를 이용해 다시 동기화하는 경우도 많다. MySQL 서버의 데이터 무결성에 민감한 서비스라면 DoubleWrite뿐만 아니라 InnoDB의 리두 로그와 복제를 위한 바이너리 로그 등 트 랜잭선을 COMMIT하는 시점에 동기화할 것들이 많다는 점에 주의하자. 즉, 리두 로그는 동기화하지 않으면서(`innodb_flush_log_at_trx_commit` 시스템 변수가 1이 아닌 경우) DoubleWrite만 활성화한다는 것은 잘못된 선택이다.

