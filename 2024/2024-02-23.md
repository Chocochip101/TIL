# 언두 로그 및 리두 로그 암호화 
테이블의 암호화를 적용하더라도 디스크로 저장되는 데이터만 암호화되고 MySQL 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리되며, 이 평문 데이터가 테이블의 데이터 파일 이외의 디스 크 파일로 기록되는 경우에는 여전히 평문으로 저장된다. 그래서 테이블 암호화를 적용해도 리두 로그나 언두 로그, 그리고 복제를 위한 바이너리 로그에는 평문으로 저장되는 것이다. MySQL 8.0.16 버전부터는 `innodb_undo_log_encrypt` 시스템 변수와 `innodb_redo_log_encrypt` 시스템 변수를 이용해 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됐다. 

테이블의 암호화는 일단 테이블 하나에 대해 암호화가 적용되면 해당 테이블의 모든 데이터가 암호화 돼야 한다. 하지만 리두 로그나 언두 로그는 그렇게 적용할 수가 없다. 즉 실행 중인 MySQL 서버에서 언두 로그나 리두 로그를 활성화한다고 하더라도 모든 리두 로그나 언두 로그의 데이터를 해당 시점에 한 번에 암호화해서 다시 저장할 수 없다. 그래서 MySQL 서버는 리두 로그나 언두 로그를 평문으로 저장하다가 암호화가 활성화되면 그때부터 생성되는 리두 로그나 언두 로그만 암호화해서 저장한다. 반대로 리두 로그와 언두 로그가 암호화되는 상태에서 암호화를 비활성화하면 그때부터 저장되는 로그 만 평문으로 저장한다. 그래서 리두 로그와 언두 로그는 암호화를 활성화했다가 비활성화한다고 해서 즉시 암호화에 사용된 키가 불필요해지는 것이 아니다. 특히 언두 로그의 경우 암호화를 비활성화한다 고 하더라도 새로 생성되는 언두 로그는 평문으로 저장되겠지만 기존의 언두 로그는 여전히 암호화된 상태로 남아있다. 그래서 상황에 따라 며칠 또는 몇 달 동안 여전히 암호화키가 필요할 수도 있다. 

리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화되고, 테이블스페이스 키는 다 시 마스터 키로 암호화된다. 즉 `ALTER INSTANCE ROTATE INNODB MASTER KEY` 명령이 실행되면 새로운 마스 터 키가 발급되고 테이블 암호화에 사용된 테이블스페이스 키와 동일하게 그 새로운 마스터 키에 의해 다시 암호화된다. 리두 로그와 언두 로그 데이터의 암호화에 테이블스페이스 키가 사용된다고 했는데, 여기서 이야기한 테이블스페이스 키는 실제 테이블의 암호화에 사용된 테이블스페이스 키가 아니라 리 두 로그와 언두 로그 파일을 위한 프라이빗 키를 의미한다. 즉 리두 로그와 언두 로그를 위한 각각의 프라이빗 키가 발급되고, 해당 프라이빗 키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일 의 헤더에 저장되는 것이다. 


InnoDB 리두 로그가 암호화됐는지는 다음과 같이 간단히 확인할 수 있다. 

```sql
mysql> SHOW GLOBAL VARIABLES LIKE 'innodb* redo_log_encrypt'; I Variable_name I Value innodb_ redo log_encrypt I OFF

nysql> INSERT INTO enc VALUES (2, 'Real-MySQL '); mysql> SET GLOBAL innodb_ redo_ log_encrypt=ON; mysql> INSERT INTO enc VALUES (2, 'Real-MongoDB '); 
```

INSERT된 레코드의 문자열이 InnoDB의 리두 로그에 보이는지만 확인해보면 된다. grep 명령을 이용 한 단순한 검색 결과에서 암호화되기 전에 INSERT한 "Real-MySQL" 문자열은 검색되지만 암호화 이후 INSERT된 "Real-MongoDB" 문자열은 검색되지 않는 것을 확인할 수 있다. 

```sql
## grep 명령의 결과, 문자열이 존재하면 "matches' "라는 메시지를 보여준다. 
## 그리고 검색한 문자열이 존재한다면 grep 명령은 반환 값으로 "θ"을 리턴한다. 
linux> grep 'Real-MySQL' ib_logfile0 ib_logfile1 
Binary file ib_logfile@ matches 
linux> echo $? 
0

## grep 명령의 결과, 문자열이 존재하지 않으면 아무런 메시지 출력이 없다. 
## 그리고 검색한 문자열이 존재하지 않으면 grep 명령은 반환 값으로 "1"을 리턴한다. 
linux> grep 'Real-MongoDB' ib_logfile0 ib_logfile1 
linux> echo $? 
1
```

