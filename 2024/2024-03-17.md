
## 다중 칼럼 인덱스
실제 서비스용 데이터베 이스에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다. 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스(또는 복합 칼럼 인덱스)라고 하며, 또한 2개 이상의 칼럼이 연결됐다고 해서 "Concatenated Index"라고도 한다. 그림 8.13은 2개 이상의 칼럼을 포함하는 다중 칼럼 인덱스의 구조를 보여준다.

![](https://velog.velcdn.com/images/chocochip/post/73924d31-55d6-438a-a9f7-e31480214f06/image.jpg)

그림 8.13에서는 편의상 루트 노드는 생략했으나 실제로 데이터 레코드 건수가 작은 경우에는 브랜치 노드가 없는 경우도 있을 수 있다. 하지만 루트 노드와 리프 노드는 항상 존재한다. 그림 8.13은 다중 칼럼 인덱스일 때 각 인덱스를 구성하는 칼럼의 값이 어떻게 정렬되어 저장되는지 설명해준다. **이 그림에서 중요한 것은 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다는 것이다.** 즉, 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다는 것이다. 그림 8.13에서는 칼럼이 2개뿐이지만, 만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되고 네 번째 칼럼은 다시 세 번째 칼럼에 의존해서 정렬된다. 위의 예제에서 `emp_no` 값의 정렬 순서가 빠르다고 하더라도 `dept_no` 칼럼의 정렬 순서가 늦다면 인덱스의 뒤쪽에 위치한다. 그래서 위의 그 림에서 `emp_no` 값이 "10003"인 레코드가 인덱스 리프 노드의 제일 마지막(하단)에 위치하는 것이다. 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 그것을 아주 신중히 결정해야 하는 이유가 바로 그것이다.

## B-Tree 인덱스의 정렬 및 스캔 방향
인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다. 하지만 어떤 인덱스가 오름차순으로 생성됐다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아니다. 사실 그 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수 있다. 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 **실시간으로 만들어 내는 실행 계획**에 따라 결정된다.

### 인덱스의 정렬
정렬 일반적인 상용 DBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다. MySQL 5.7 버전까지는 칼럼 단위로 정렬 순서를 혼합(ASC와 DESC 혼합)해서 인덱스를 생성할 수 없었다. 이런 문제점을 해결하기 위해 숫자 칼럼의 경우 -1을 곱한 값을 저장하는 우회 방법을 사용했었다. 하지만 MySQL 8.0 버전부터는 다음과 같은 형태의 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다. 

```sql
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```
> 아마도 MySQL 5.7에서도 위와 같이 오름차순 칼럼과 내림차순 칼럼을 혼합한 인덱스를 생성했다고 기억하는 사용자도 있을 것이다. 실제 이렇게 인덱스를 생성해도 아무런 에러 없이 인덱스가 생성됐을 것이다. 하지만 실제 인덱 스는 모두 오름차순 정렬만으로 인덱스가 생성됐다. MySQL 5.7 버전까지는 ASC 또는 DESC 키워드는 앞으로 만들 어질 버전에 대한 호환성을 위해 문법상으로만 제공된 것이다. 

#### 인덱스 스캔 방향
`first_name` 칼럼에 대한 인덱스가 포함된 employees 테이블에 대해 다음 쿼리를 실행하는 과정을 살펴보자. MySQL은 이 퀴리를 실행하기 위해 인덱스를 처음부터 오름차순으로 끝까지 읽어 `first_name`이 가장 큰(오름차순으로 읽었을 때 가장 마지막 레코드) 값 하나를 가져오는 것일까?

```sql
mysql> SELECT * FROM employees ORDER BY first_name DESC LIMIT 1; 
```

그렇지 않다. 인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로 값을 가져올 수 있고, 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다. **그래서 위의 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다.** 그림 8.14는 인덱스를 정순으로 읽는 경우와 역순으로 읽는 경우를 보여준다.

![](https://velog.velcdn.com/images/chocochip/post/a336b8ed-8081-4cfd-9aa0-de58600fa902/image.jpg)

즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다. 오름차순으로 생성된 인덱스를 정순으로 읽으면 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과가 되고, 역순으로 읽으면 그 결과는 내림차순으로 정렬된 상태가 되는 것이다.

```sql
mysql> SELECT * FROM employees WHERE first_name>='Anneke' ORDER BY first_name ASC LIMIT 4; 
mysql> SELECT * FROM employees ORDER BY first_name DESC LIMIT 5; 
```
위의 첫 번째 퀴리는 `first_name` 칼럼에 정의된 인덱스를 이용해 "Anneke"라는 레코드를 찾은 후, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가져오면 아무런 비용을 들이지 않고도 원하는 정렬 효과를 얻을 수 있다. 두 번째 쿼리는 이와 반대로 employees 테이블의 first_name 칼럼에 정의된 인덱스를 역순으로 읽으면서 처음 다섯 개의 레코드만 가져오면 된다. 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 **최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.**

#### 내림차순 인덱스

##### 내림차순, 오름차순 인덱스 내부성능 비교
MySQL 서버에서 다음 두 쿼리는 실제 내림차순인지 오름차순인지와 관계없이 인덱스를 읽는 순서만 변경해서 해결할 수 있다는 것을 살펴봤다.

```sql 
mysql> SELECT * FROM employees ORDER BY first_name ASC LIMIT 10; 
mysql> SELECT * FROM employees ORDER BY first_name DESC LIMIT 10; 
```

물론 다음과 같이 2개 이상의 칼럼으로 구성된 복합 인덱스에서 각각의 칼럼이 내림차순과 오름차순이 혼합된 경우에는 MySQL 8.0의 내림차순 인덱스로만 해결될 수 있다.
```sql
mysql> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC,user_score DESC); 
```
그렇다면 `first_name` 칼럼을 역순으로 정렬하는 요건만 있다면 다음 2개 인덱스 중에서 어떤 것을 선택 하는 것이 좋을까? 아니면 두 인덱스 모두 동일한 성능을 보일까?

```sql
mysql> CREATE INDEX ix_ firstname_asc ON employees (first_name ASC ); 
mysql> CREATE INDEX ix_ firstname_ desc ON employees (first_name DESC); 
```
이 궁금중에 대한 답을 찾기 위해 MySQL 8.0부터 지원되는 내림차순 인덱스에 대해 조금 깊이 있게 살펴보자. 

우선 내용의 이해도를 높이기 위해 간단히 용어를 그림 8. 15와 같이 정리했다.

![](https://velog.velcdn.com/images/chocochip/post/ba345481-ae99-4754-9527-79e1c8030bf0/image.jpg)

- 오름차순 인덱스(Ascending index): 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 내림차순 인덱스(Descending index): 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스 
- 인덱스 정순 스캔(Forward index scan): 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스 역순 스캔(Backward index scan): 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부 터 왼쪽으로 스캔 

이제 내림차순 인덱스의 필요성에 대해 간단한 테스트 결과를 살펴보면서 알아보자. 간단한 테스트를 위해 다음과 같이 테스트용 테이블을 생성하고 대략 1천만 건 정도의 레코드를 준비해, 따져 보면 **역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 더 시간이 걸리는 것을 확인할 수 있다.** 하나의 인덱스를 정순으로 읽느냐 또는 역순으로 읽느냐에 따라 이런 차이가 발생한다는 것은 쉽게 이해하기 어려울 수 있다. MySQL 서버의 InnoDB 스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지(블록) 간의 양방향 연결 고리(Double linked list)를 통해 전진(Forward)하느냐 후진(Backward)하느냐의 차이만 있지만, 실제 내부적으로는 InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수밖에 없는 다음의 두 가지 이유가 있다.

- 페이지 잠금이 인덱스 정순 스캔(Forward index scan)에 적합한 구조 
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조(그림 8.16에서 보다시피 InnoDB 페이지 내부에서 레코드들이 단방향으로만 링크를 가진 구조다.) 


![](https://velog.velcdn.com/images/chocochip/post/f096cd81-fc01-42d5-96da-2829fe253456/image.jpg)


> 그림 8.16에서는 InnoDB 페이지 내부에서 레코드들이 정렬 순서대로 저장돼 있는 것처럼 표시돼 있지만 실제로 InnoDB 페이지는 힙(Heap)처럼 사용되기 때문에 물리적으로 저장이 순서대로 배치되지는 않는다. 그리고 각 데이터 페이지(innoDB 스토리지 엔진에서 데이터 파일은 프라이머리 키 인덱스 자체라는 것에 주의하자)나 인덱스 페이지의 엔트리(데이터 레코드 또는 인덱스 키)는 키 값과 데이터를 가지는데, 인덱스(프라이머리 키 인덱스와 세컨더리 인덱스 모두)의 루트 노드 또는 브랜치 노드라면 자식 노드의 주소를 가진다. 프라이머리 키에서 리프 노드의 "데이터"는 실제 레코드의 칼럼 값들이며, 세컨더리 인덱스 페이지에서는 프라이머리 키 값을 가진다.

##### 인덱스 정렬 순서 선택
내림차순과 오름차순 인덱스의 내부적인 차이로 인한 성능을 살펴봤다. 이제 서비스 요건에 맞게 어떤 정렬 순서의 인덱스를 선택해야 할지 살펴보자. 일반적으로 인덱스를 ORDER BY DESC하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요는 없어 보인다. 예를 들어, 다음 쿼리를 한번 살펴보자. 
```sql
mysql> SELECT * FROM tab WHERE userid=? ORDER BY score DESC LIMIT 10;
```
이 퀴리의 경우 다음 두 가지 인덱스 모두 적절한 선택이 될 수 있다.
```
오름차순 인덱스: INDEX (userid ASC, score ASC) 
내림차순 인덱스: INDEX (userid DESC, score DESC) 
```
하지만 위 쿼리가 많은 **레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적이라고 볼 수 있다. **

또한 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다. 
