# B-Tree 인덱스
B-Tree는 칼럼의 원본 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다. 특별한 경우가 아닌 경우, 대부분 인덱스는 B-Tree를 사용한다.

## 구조 및 특성
B-Tree는 트리구조의 최상위에 하나의 **루트 노드(Root Node)**가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. 트리 구조의 최상위에 하나의 ""데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

![](https://velog.velcdn.com/images/chocochip/post/70ba7753-db21-4efe-9205-f2fdf6e833e7/image.jpeg)


위 그림과 같이 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다. 데이터 파일의 레코드는 삭제와 변경이 존재하기에 항상 INSERT된 순서로 존재하지 않는다. 만약 전혀 삭제와 변경이 이루어지지 않았다면, 맞을 수도 있다. 레코드가 삭제되어 빈 공간이 생기면 그 다음의 INSERT는 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되지 않는다.

인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 **인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.**

![](https://velog.velcdn.com/images/chocochip/post/031966b8-f87d-4d32-ad88-0c29dbbd620b/image.jpeg)

위 그림은 InnoDB 테이블의 인덱스의 데이터 파일의 관계를 보여주는데, InnoDB 스토리지 엔진을 사용하는 테이블에서느누 PK가 ROWID 역할을 한다. MyISAM과 InnoDB의 인덱스에서 큰 차이점은 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법에 있다. MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 PK를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.

따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일에 바로 접근할 수 없다. 그림에서와 같이 인덱스에 저장돼 있는 PK 값을 이용해 **PK 인덱스를 한 번 더 검색한 후, PK 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.** 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK를 저장하고 있는 B-Tree를 검색해야 한다.

## B-Tree 인덱스 키 추가 및 삭제
테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다. 인덱스 키 추가나 삭제가 어떻게 처리되는지 알아두면 쿼리의 성능을 쉽게 예측할 수 있을 것이다.

### 인덱스 키 추가
새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다. B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.

#### 인덱스 추가 오버헤드 예측
인덱스 추가로 인한 영향은 테이블 칼럼의 수, 칼럼의 크기, 인덱스 칼럼의 특성 등이 INSERT나 UPDATE 문장에 영향을 준다. 대략적으로 테이블에 레코드를 추가하는 작업을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5라 예측한다.

> 예를 들어 테이블에 인덱스가 3개가 있다면 이때 테이블에 인덱스가 하나도 없는 경우는 작업 비용이 1이고, 3개인 경우에는 5.5(1.5 * 3 + 1) 정도로 예측한다.

MyISAM이나 MEMORY 스토리지 엔진은 INSERT 문장이 실행될 경우 즉시 새로운 키 값을 B-Tree 인덱스에 저장한다. 하지만 InnoDB 스토리지 엔진은 이 작업을 **체인지 버퍼**로 지연시켜 나중에 처리한다. 하지만 PK나 유니크 인덱스의 경우 중복 확인이 필요하기 때문에 즉시 B-Tree에 추가된다.

### 인덱스 키 삭제
인덱스 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크만 하면 작업이 완료된다. 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. 

인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 I/O 작업이 필요하다. MySQL 5.5버전 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 체인지 버퍼에서 버퍼링되어 지연 처리될 수 있다. 처리가 지연된 인덱스 키 삭제 또한 사용자에게는 특별한 악영향 없이 MySQL 서버가 내부적으로 처리하므로 특별히 걱정할 것이 없다.

> MyISAM이나 MEMORY 스토리지 엔진은 인덱스 키 삭제가 완료된 후에 쿼리 실행이 완료된다.

### 인덱스 키 변경
인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값을 변경하는 것이 불가능하다. **따라서 B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.** 변경 작업 또한 체인지 버퍼를 활용해 지연 처리될 수 있다.

### 인덱스 키 검색
인덱스 추가, 삭제, 변경 작업을 희생하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다. 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색"이라고 한다. 인덱스 트리 탐색은 `SELECT`에서만 사용하는 것이 아닌 `UPDATE`나 `DELETE`를 처리하기 위해 항상 레코드를 먼저 검색해야하는 경우에도 사용된다.

B-Tree 인덱스 검색이 사용 가능한 경우)
- 100% 일치 검색
- 값의 앞부분만 일치하는 검색
- 부등호("<", ">") 비교 조건의 검색

B-Tree 인덱스 검색이 사용 불가능한 경우)
- 키 값의 뒷부분만 검색하는 경우
- 인덱스의 키 값에 변형이 가해진 후 비교되는 경우
- 함수나 연산을 수행한 결과로 정렬 또는 검색하는 작업


InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다. 따라서 `UPDATE`나 `DELETE` 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.
