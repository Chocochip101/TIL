# 바이너리 로그 암호화 
테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문을 저장한다. 일반적으로 언두 로그와 리두 로그는 길지 않은 시간 동안의 데이터만 가지기 때문에 크게 보안에 민감하지 않을 수 있지만 바이너리 로그는 의도적으로 상당히 긴 시간 동안 보관하는 서비스도 있고 때로는 증분 백업(Incremental Backup)을 위해 바이너리 로그를 보관하기도 한다. 이런 이유로 바이너리 로그 파일의 암호화는 상황에 따라 중요도가 높아질 수도 있다. 


바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하 고, MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터 를 암호화하지는 않는다. 복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하고자 한다면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정하면 된다.

## 바이너리 로그 암호화 키 관리 
바이너리 로그와 릴레이 로그 파일 데이터의 암호화를 위해서도 MySQL 서버는 그림 7.3과 같이 2단 암호화 키 관리 방식을 사용한다. 

![](https://velog.velcdn.com/images/chocochip/post/5cd4cf0d-a60a-4761-ba12-37236c45c987/image.jpeg)

바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키(File Key)로 암호화해서 디스크로 저장하고, 파 일 키는 "바이너리 로그 암호화 키"로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장 된다. 즉 "바이너리 로그 암호화 키"는 테이블 암호화의 마스터 키와 동일한 역할을 하며, 파일 키는 바 이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용 된다. 

## 바이너리 로그 암호화 키 변경
바이너리 로그 암호화 키는 다음과 같이 변경(로테이션)할 수 있다. 
```sql
mysql> ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```


바이너리 로그 암호화 키가 변경되면 다음의 과정을 거친다. 

1. 증가된 시권스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장 
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션) 
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장 
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장 (암호화되지 않은 로그 파일은 무시) 
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로 그 암호화 키를 키링 파일에서 제거 

이 절차에서 4번 과정은 상당히 시간이 걸리는 작업일 수 있는데, 이를 위해 키링 파일에서 "바이너리 로그 암호화 키"는 내부적으로 버전(시퀀스 번호) 관리가 이뤄진다. 예를 들어, 많은 바이너리 로그와 릴레이 로그를 가진 MySQL 서버에서 `ALTER INSTANCE ROTATE BINLOG MASTER KEY` 명령을 연속으로 2번 실행한다면 키링 파일에는 순차적인 시퀀스 번호를 가지는 3개의 바이너리 로그 암호화 키가 존재할 것이다. 그리고 바이너리 로그와 릴레이 로그 파일들을 최근 순서대로 파일 키를 다시 암호화해서 저장 하는 작업을 수행한다. 모든 바이너리 로그와 릴레이 로그 파일의 파일 키가 새로운 바이너리 로그 암 호화 키로 암호화되어 저장되면 더이상 기존 바이너리 로그 암호화 키는 필요치 않으므로 키링 파일에서 제거될 것이다. 

MySQL 서버의 바이너리 로그 파일이 암호화돼 있는지 여부는 다음과 같이 확인할 수 있다. 

```sql
mysql> SHOW BINARY LOGS; 
i Log_name : File_size I Encrypted mysql-bin. 000010 mysql-bin. 000011 I 2853 I No 1337 I Yes 
```
## mysqlbinlog 도구 활용 
MySQL 서버에서는 트랜잭션의 내용을 추적하거나 백업 복구를 위해 암호화된 바이너리 로그를 평문 으로 복호화할 일이 자주 발생한다. 하지만 한 번 바이너리 로그 파일이 암호화되면 바이너리 로그 암호화 키가 없으면 복호화할 수 없다. 그런데 바이너리 로그 암호화 키는 MySQL 서버만 가지고 있어서 복호화가 불가능하다. mysqlbinlog 도구를 이용해 암호화된 바이너리 로그 파일의 내용을 SQL 문장으 로 한번 풀어보면 다음과 같이 암호화된 바이너리 로그 파일을 직접 열어 볼 수는 없다는 에러 메시지를 출력한다. 

```sql
linux> mysqlbinlog -vvv mysql-bin.00011 
Enter password: 
/*150530 SET @OSESSION. PSEUDO _SLAVE_MODE=1*/; 
/*!50003 SET @OLD_COMPLETION_TYPE=GOCOMPLETION_TYPE, COMPLETION_ _TYPE=0*/;
DELIMITER /*!*/; 
ERROR: Reading encrypted log files directly is not supported. 
SET @SESSION. GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file 
/*!50003 SET COMPLETION_ TYPE=@OLD__COMPLETION_TYPE*/; 
/*!50530 SET @OSESSION.PSEUDO_SLAVE_MODE=0*/; 
```

바이너리 로그 암호화 키는 그 바이너리 로그나 릴레이 로그 파일을 생성한 MySQL 서버만 가지고 있기 때문에 MySQL 서버와 관계없이 mysqlbinlog 도구만으로는 복호화할 방법이 없다. 그래서 예전처럼 다른 서버로 복사하거나 바이너리 로그 파일을 백업하는 것은 소용없어졌다. 

그나마 바이너리 로그 파일의 내용을 볼 수 있는 방법은 MySQL 서버를 통해 가져오는 방법이 유일하다. 즉 현재 MySQL 서버가 mysql-bin.000011 로그 파일을 가지고 있다는 가정하에 mysql-bin,000011 로그 파일의 내용을 확인하고자 한다면 다음과 같이 mysqlbinlog 도구가 MySQL 서버 에 접속해서 바이너리 로그를 가져오는 방법밖에 없다. 다음 예제에서 파라미터로 주어진 mysql bin,000011은 MySQL 서버에게 요청할 바이너리 로그 파일의 이름일 뿐, mysqlbinlog 도구가 직접 mysql-bin.00011 파일을 읽는 것은 아니다. 그래서 mysqlbinlog 명령을 실행할 때 "--read-from- remote-server" 파라미터와 함께 MySQL 서버 접속 정보를 입력한다.

```sql
linux> mysqlbinlog --read-from-remote-server -uroot -p -vvv mysql-bin.00011
```


